# shm_talk
共享内存聊天室
简易聊天服务器：实现命令行下的局域网的群聊功能。
多进程+共享内存+事件驱动的epoll（I/O多路复用模型）
父进程：创建监听文件描述符，接受客户端的连接，并创建子进程分别去处理每个连接。对于每个客户连接，有一个client_data（处理每个客户连接必要的数据）,它记录每个客户的socket地址，socket文件描述符，处理这个连接的子进程的PID，以及子进程和父进程通信用的管道。
父进程epoll监听的事件包括listenfd，父进程和子进程通信的管道事件pipefd[1]，还有就是信号管道事件sig_pipefd[0]，每产生一个信号，信号处理函数做的事情就是就是往信号管道里将该信号发送给父线程，然后父进程epoll机制便能监听到是什么信号，然后去做相应的处理，如是子进程终止信号SIGCHLD，就调用waitpid等待子进程的终止，然后将相应资源释放，不需要监听文件描述符给delete，相应client_data数据的删除，用户数量减一等，如果此时用户数减为0了，stop_server=true;便终止服务器。
父进程和子进程的共享内存主要靠shm_open()函数先打开一个用于内存映射的文件，然后用mmap函数将其映射到进程的（虚拟）内存映射空间中，用于父子进程的共享读。其实每个子进程只会往自己所处理的客户连接所对应的那部分缓存写入数据，大多数部分是为了实现聊天消息的共享读，这样每个子进程在使用共享内存时候无需加锁。这样做符合聊天室服务器场景，同时也提高了程序性能。
子进程：主要用于处理和客户端的连接，其使用epoll监听两个读文件描述符，一个就是与客户端连接的connfd，客户端来一段数据（来一段话），子进程往自己所对应那部分缓存中写入数据（也就是写入共享内存那一段），写完后，就通过父子进程的管道将是第几（idx）个客户来了数据发送给父进程，父进程就收到这个idx，然后向其他所有子进程（除idx外）发送idx，就是取告诉子进程第idx个人发来了数据，我要去读取它，然后把读取内容返还给自己连接的客户端；第二个监听文件描述符也就是父子进程之间的管道文件描述符，数据也就是这个idx了。
